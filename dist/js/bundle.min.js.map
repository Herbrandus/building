{"version":3,"sources":["node_modules/browser-pack/_prelude.js","bundle.min.js","src/ts/builder.component.ts","src/ts/config.component.ts","src/ts/main.ts","src/ts/mapGenerationFunctions.component.ts","src/ts/mapper.component.ts","src/ts/tile.component.ts"],"names":["r","e","n","t","o","i","f","c","require","u","a","Error","code","p","exports","call","length","1","module","Object","defineProperty","value","mapGenerationFunctions_component_1","config_component_1","Builder","[object Object]","this","config","Config","calculations","MapGenerationFunctions","map","html","mapWidth","mapLength","tileWidth","tileLength","htmlMap","getMapWidth","y","x","getColumn","isDefined","tile","getTopTile","tileTopColor","getColor","rgb","id","mapTotalWidth","mapTotalLength","testTile","createTile","yDeviation","coords","bottom","top","right","left","tileHalfWidthLeft","tileHalfWidthRight","tileHalfLengthTop","mapLengthTop","mapLengthBottom","Math","round","lastTile","startTileX","thisPosY","thisPosX","newTile","xPos","yPos","tileW","tileL","tileColor","groundColor","hex","dimensions","calculateStraightLinesFromIsometricSquare","horizontalWidthFromTop","verticalHeightFromTop","horizontalWidthFromBottom","totalHeight","totalWidth","verticalHeightFromBottom","pointLeft","./config.component","./mapGenerationFunctions.component","2","_tileWidth","_tileLength","_tileHeight","_tileSmallAngle","_tileLargeAngle","_groundColor","Color","_buildingBaseColor","floor","random","tileHeight","tileSmallAngle","tileLargeAngle","buildingBaseColor","mapArrayWidth","mapArrayLength","3","mapper_component_1","builder_component_1","building","_builder","_map","default","showData","build2DMap","buildMap","document","querySelector","innerHTML","drawTileMap","./builder.component","./mapper.component","4","smallAngle","largeAngle","maximumBlockIterations","adjacent","opposite","sum","pow","sqrt","blockWidth","blockHeight","smallOuterAngle","largeOuterAngle","getHorizontalBottomShortestWidth","getVerticalBottomShortestHeight","getHorizontalTopLongestWidth","getVerticalTopLongestHeight","diagonalWidth","ceil","sin","toRadians","diagonalHeight","cos","angle","PI","TileColor","BuildingHeightVariations","params","_hexNames","error","validateHex","hexColor","charAt","setHex","hexToRgb","validateRgb","setRgb","rgbToHex","toString","g","b","_colorRgb","hexadecimal","hexVal1","hexVal2","hexVal3","_colorHex","match","hexValues","substr","split","hexPair1","indexOf","hexPair2","hexPair3","hexR","Number","hexG","hexB","5","tile_component_1","mapMaxHeight","mapEdgeWidth","averageBuildingSize","_mapGen","_blockHeightVariationLabels","TallCenter","TallSurrounds","Random","_blockHeightVariation","_mapWidth","_mapLength","_mapMaxHeight","_mapEdgeWidth","_averageBuildingSize","_blockHeight","_maximumBlockIterations","_additionalBlockIterations","calculateAdditionalBlockIterations","_blockGroups","mapLengthHalf","startblockLength","startblockWidth","startblockXfromCenter","startblockLengthHalf","startingPositionX","_world","firstBlockHeight","console","log","thisBlockGroup","column","Column","tileStack","h","thisPillar","thisWindowed","isRoof","push","Tile","TileType","Body","roof","pillar","windowed","tower","Array","blockGroup","height","corner","setEdges","getTile","edge","defined","colX","colY","colHeight","_edge","_tileStack","_defined","_x","_y","_height","groupNum","_blockGroup","_corner","tiles","./tile.component","6","tileType","options","_options","_id","_h","_tileType","_tileColor","type","None"],"mappings":"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","file":"bundle.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()",null,"import { MapGenerationFunctions } from './mapGenerationFunctions.component'\nimport Map from './mapper.component'\nimport { Tile, TileType } from './tile.component'\nimport { Config, Coords, TileTemplate, Position } from './config.component'\n\nexport class Builder {\t\n\n\tprivate config: Config = new Config()\n\tprivate calculations: MapGenerationFunctions = new MapGenerationFunctions()\n\n\tconstructor() {\t}\n\n\tshowData(map: Map): string {\n\n\t\tlet html = '<div class=\"showData\">'\n\t\thtml += `map width: ${map.mapWidth} tiles<br>map length: ${map.mapLength} tiles<br>`\n\t\thtml += `tile width: ${this.config.tileWidth}<br>tile length: ${this.config.tileLength}<br>`\n\t\thtml += '</div>'\n\n\t\treturn html\n\t}\n\n\tbuild2DMap(map: Map): string {\n\n\t\tlet htmlMap = `<div class=\"map\" style=\"width:${this.config.getMapWidth(map.mapWidth)}px;\">`\n\n\t\tfor (let y = 0; y < map.mapLength; y++) {\n\t\t\tfor (let x = 0; x < map.mapWidth; x++) {\n\n\t\t\t\thtmlMap += `<div class=\"tile\" style=\"width:${this.config.tileWidth}px;height:${this.config.tileLength}px;`\n\n\t\t\t\tif (map.getColumn(x, y).isDefined) {\n\t\t\t\t\t\n\t\t\t\t\tlet tile = map.getTopTile(x, y)\n\t\t\t\t\tlet tileTopColor = tile.getColor().rgb()\n\t\t\t\t\tlet tileColor = `rgb(${tileTopColor['r']}, ${tileTopColor['g']}, ${tileTopColor['b']})`\n\n\t\t\t\t\thtmlMap += `background-color:${tileColor}\">${tile.id}<br>(${x}, ${y})</div>`\n\n\t\t\t\t} else {\n\n\t\t\t\t\thtmlMap += `\">${x}, ${y}</div>`\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\thtmlMap += `</div>`\n\n\t\treturn htmlMap\n\t}\n\n\tbuildMap(map: Map): string {\n\n\t\tlet mapTotalWidth = map.mapWidth\n\t\tlet mapTotalLength = map.mapLength\n\n\t\tlet testTile = this.createTile(0, 0)\n\n\t\tlet xDeviation = testTile.coords.bottom.x - testTile.coords.top.x\n\t\tlet yDeviation = testTile.coords.right.y - testTile.coords.left.y\n\t\tlet tileHalfWidthLeft = testTile.coords.top.x - testTile.coords.left.x\n\t\tlet tileHalfWidthRight = testTile.coords.right.x - testTile.coords.top.x\n\t\tlet mapWidthLeft = tileHalfWidthLeft * mapTotalLength\n\t\tlet mapWidthRight = tileHalfWidthRight * mapTotalWidth\n\t\tlet tileHalfLengthTop = testTile.coords.right.y\n\t\tlet tileHalfLengthBottom = testTile.coords.bottom.y - testTile.coords.right.y\n\t\tlet mapLengthTop = tileHalfLengthTop * mapTotalWidth\n\t\tlet mapLengthBottom = tileHalfLengthBottom * mapTotalLength\n\t\tlet mapWidthPx = Math.round((tileHalfWidthLeft + tileHalfWidthRight) * (mapTotalWidth ))\n\t\tlet mapLengthPx = Math.round(mapLengthTop + mapLengthBottom)\n\n\t\tlet html = '<svg width=\"'+mapWidthPx+'\" height=\"'+mapLengthPx+'\">'\n\n\t\tlet lastTile = null\n\t\tlet startTileX = tileHalfWidthLeft * (mapTotalWidth - 1)\n\n\t\tfor (let y = 0; y < mapTotalLength; y++) {\n\n\t\t\tfor (let x = 0; x < mapTotalWidth; x++) {\n\n\t\t\t\tlet thisPosY = 0\n\t\t\t\tlet thisPosX = 0\n\n\t\t\t\tif (x === 0 && y === 0) {\n\t\t\t\t\tthisPosX = startTileX\n\t\t\t\t}\n\n\t\t\t\tif (lastTile != null) {\n\t\t\t\t\tthisPosY = lastTile.coords.right.y\n\t\t\t\t}\n\n\t\t\t\tif (y > 0 && x === 0) {\n\t\t\t\t\tthisPosX = startTileX - (tileHalfWidthLeft * y)\n\t\t\t\t\tthisPosY = (tileHalfLengthTop * y) - (yDeviation * y)\n\t\t\t\t}\t\n\t\t\t\t\n\t\t\t\tif (x > 0) {\n\t\t\t\t\tthisPosX = (lastTile.coords.right.x - (lastTile.coords.right.x - lastTile.coords.bottom.x))\n\t\t\t\t}\n\n\t\t\t\tlet newTile = this.createTile(thisPosX, thisPosY)\n\n\t\t\t\thtml += newTile.html\n\n\t\t\t\tlastTile = newTile\n\t\t\t}\n\t\t}\n\n\t\thtml += '</svg>'\n\n\t\treturn html\n\t}\n\n\tcreateTile(xPos: number, yPos: number): TileTemplate {\n\n\t\tlet tileW = this.config.tileWidth\n\t\tlet tileL = this.config.tileLength\n\n\t\tlet tileColor = this.config.groundColor.hex()\n\n\t\tlet dimensions = this.calculations.calculateStraightLinesFromIsometricSquare(tileW, tileL)\n\n\t\tlet top: Position = { \"x\": (xPos + dimensions.horizontalWidthFromTop), \"y\": yPos}\n\t\tlet left: Position = { \"x\": xPos, \"y\": (yPos + dimensions.verticalHeightFromTop) }\n\t\tlet bottom: Position = { \"x\": (xPos + dimensions.horizontalWidthFromBottom), \"y\": (yPos + dimensions.totalHeight) }\n\t\tlet right: Position = { \"x\": (xPos + dimensions.totalWidth), \"y\": (yPos + dimensions.verticalHeightFromBottom) }\n\n\t\tlet pointTop = `${top.x} ${top.y}`\n\t\tlet pointLeft = `${left.x} ${left.y}`\n\t\tlet pointBottom = `${bottom.x} ${bottom.y}`\n\t\tlet pointRight = `${right.x} ${right.y}`\n\n\t\tvar html = `<path fill=\"${tileColor}\"\n\t\t\t\t\td=\"M${pointLeft} \n\t\t\t\t\tL${pointBottom} \n\t\t\t\t\tL${pointRight} \n\t\t\t\t\tL${pointTop} \n\t\t\t\t\tL${pointLeft} Z\" />`\n\n\t\tlet coords: Coords = { \"top\": top, \"left\": left, \"bottom\": bottom, \"right\": right }\n\n\t\treturn { html: html, coords: coords }\n\t}\n}\n","import { Color } from './mapGenerationFunctions.component'\n\nexport class Config {\n\n\tprivate _tileWidth: number = 35\n\tprivate _tileLength: number = 35\n\tprivate _tileHeight: number = 20\n\tprivate _tileSmallAngle: number = 85\n\tprivate _tileLargeAngle: number = 100\n\tprivate _groundColor: Color = new Color('dbc')\n\tprivate _buildingBaseColor: Color = new Color(\n\t\t125 + Math.floor(Math.random() * 75),\n\t\t170 + Math.floor(Math.random() * 40),\n\t\t180 + Math.floor(Math.random() * 30)\n\t)\n\n\tpublic get tileWidth(): number {\n\t\treturn this._tileWidth\n\t}\n\n\tpublic get tileLength(): number {\n\t\treturn this._tileLength\n\t}\n\n\tpublic get tileHeight(): number {\n\t\treturn this._tileHeight\n\t}\n\n\tpublic get tileSmallAngle(): number {\n\t\treturn this._tileSmallAngle\n\t}\n\n\tpublic get tileLargeAngle(): number {\n\t\treturn this._tileLargeAngle\n\t}\n\n\tpublic get groundColor(): Color {\n\t\treturn this._groundColor\n\t}\n\n\tpublic get buildingBaseColor(): Color {\n\t\treturn this._buildingBaseColor\n\t}\n\n\tpublic getMapWidth(mapArrayWidth: number): number {\n\t\treturn mapArrayWidth * this._tileWidth\n\t}\n\n\tpublic getMapLength(mapArrayLength: number): number {\n\t\treturn mapArrayLength * this._tileLength\n\t}\n}\n\nexport interface Coords {\n\ttop?: Position,\n\tleft?: Position,\n\tbottom?: Position,\n\tright?: Position\n}\n\nexport interface TileTemplate {\n\thtml?: string,\n\tcoords?: Coords\n}\n\nexport interface Position {\n\tx?: number,\n\ty?: number\n}\n","import Map from './mapper.component'\nimport { Builder } from './builder.component'\n\nclass RandomBuilding {\n\n\tprivate _map: Map\n\tprivate _builder: Builder = new Builder\n\n\tconstructor() {\n\t\tthis._map = new Map(20, 20, 10, 2, (4 + Math.floor(Math.random() * 7)), 2, 4)\n\t}\n\n\tget map() {\n\t\treturn this._map\n\t}\n\n\tpublic colorMap(): string {\n\t\treturn this._builder.showData(this._map) + this._builder.build2DMap(this._map)\n\t}\n\n\tpublic drawTileMap(): string {\n\t\treturn this._builder.buildMap(this._map)\n\t}\n}\n\nconst building = new RandomBuilding();\n\n//document.querySelector('#world').innerHTML = building.colorMap()\n\ndocument.querySelector(\"#world\").innerHTML = building.drawTileMap()","import { Config } from './config.component'\n\nexport class MapGenerationFunctions {\n\n\tprivate config: Config = new Config();\n\tsmallAngle = this.config.tileSmallAngle;\n\tlargeAngle = this.config.tileLargeAngle;\n\n\tconstructor() { }\n\n\tpublic calculateAdditionalBlockIterations(maximumBlockIterations: number) {\n\t\treturn 2 + Math.floor(Math.random() * maximumBlockIterations);\n\t}\n\n\tpublic calculateTriangleHypotenuse(adjacent: number, opposite: number): number {\n\t\tlet sum = Math.pow(adjacent, 2) + Math.pow(opposite, 2);\n\t\tlet result = Math.sqrt(sum);\n\t\treturn result\n\t}\t\n\n\t// calculate the dimensions to draw the isometric perspective tile with the parameters as if it were a straight square tile\n\tpublic calculateStraightLinesFromIsometricSquare (blockWidth: number, blockHeight: number) {\n\t\t// lengths this function returns when it comes to positions of longest and shortest sides as array\n\t\t/*           [0]\n\t\t *   _________________ \n\t\t *   |    [3]  |      |\n\t\t *   | [5]            |\n\t\t *   |               -|\n\t\t *   |-               | [1]\n\t\t *   | [4]            |\n\t\t *   |    [2]         |\n\t\t *   |_______|________|\n\t\t */  \n\n\t\tlet smallOuterAngle = (180 - this.smallAngle) / 2;\n\t\tlet largeOuterAngle = (180 - this.largeAngle) / 2;\n\n\t\tlet horizontalWidthFromBottom = this.getHorizontalBottomShortestWidth(blockWidth, smallOuterAngle);\n\t\tlet verticalHeightFromBottom = this.getVerticalBottomShortestHeight(horizontalWidthFromBottom, smallOuterAngle);\n\n\t\tlet horizontalWidthFromTop = this.getHorizontalTopLongestWidth(blockHeight, largeOuterAngle);\n\t\tlet verticalHeightFromTop = this.getVerticalTopLongestHeight(horizontalWidthFromTop, largeOuterAngle);\n\n\t\tlet totalHeight = verticalHeightFromBottom + verticalHeightFromTop;\n\t\tlet totalWidth = horizontalWidthFromBottom + horizontalWidthFromTop;\n\n\t\treturn {\t'totalWidth': totalWidth, \n\t\t\t\t\t'totalHeight': totalHeight, \n\t\t\t\t\t'horizontalWidthFromBottom': horizontalWidthFromBottom, \n\t\t\t\t\t'horizontalWidthFromTop': horizontalWidthFromTop, \n\t\t\t\t\t'verticalHeightFromBottom': verticalHeightFromBottom, \n\t\t\t\t\t'verticalHeightFromTop': verticalHeightFromTop }\n\t}\n\n\t// calculate the amount of pixels from the bottom left side of a straight square to the point at the bottom \n\t// .. where the tip of the tile meets the border of the square\n\tpublic getHorizontalBottomShortestWidth (diagonalWidth: number, smallAngle: number): number {\n\t\treturn Math.ceil((diagonalWidth * Math.sin(this.toRadians(smallAngle))) * 100) / 100;\n\t}\n\n\tpublic getVerticalBottomShortestHeight (diagonalHeight: number, smallAngle: number): number {\n\t\treturn Math.ceil((diagonalHeight * Math.cos(this.toRadians(smallAngle))) * 100) / 100;\n\t}\n\n\tpublic getHorizontalTopLongestWidth (diagonalWidth: number, largeAngle: number): number {\n\t\treturn Math.ceil((diagonalWidth * Math.sin(this.toRadians(largeAngle))) * 100) / 100;\n\t}\n\n\tpublic getVerticalTopLongestHeight (diagonalHeight: number, largeAngle: number): number {\n\t\treturn Math.ceil(diagonalHeight * Math.cos(this.toRadians(largeAngle)));\n\t}\n\n\ttoRadians (angle: number): number {\n\t\treturn angle * (Math.PI / 180);\n\t}\n}\n\nexport enum TileColor {\n\tRed = 125 + Math.floor(Math.random() * 75),\n\tGreen = 170 + Math.floor(Math.random() * 40),\n\tBlue = 180 + Math.floor(Math.random() * 30)\n}\n\nexport enum BuildingHeightVariations {\n\tTallCenter = 'tallCenter',\n\tTallSurrounds = 'tallSurrounds',\n\tRandom = 'random'\n}\n\nexport class Color {\n\tprivate _hexNames: string[] = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f']\n\tprivate _colorRgb: RGB\n\tprivate _colorHex: string\n\n\tconstructor(...params: any[]) {\n\t\tlet error = null\n\t\tif (params.length === 1) {\n\t\t\tif (typeof params[0] === 'string') {\n\t\t\t\tif (this.validateHex(params[0])) {\n\t\t\t\t\tlet hexColor = params[0]\n\t\t\t\t\tif (hexColor.charAt(0) !== '#') {\n\t\t\t\t\t\thexColor = `#${hexColor}`\n\t\t\t\t\t}\n\t\t\t\t\tthis.setHex(hexColor)\n\t\t\t\t\tthis.hexToRgb()\n\t\t\t\t} else {\n\t\t\t\t\terror = \"Hexadecimal color is incorrect\"\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terror = \"Length of 1 in parameters is not equal to string\"\n\t\t\t}\n\t\t} else if (params.length === 3) {\n\t\t\tif (this.validateRgb(params)) {\n\t\t\t\tthis.setRgb(params[0], params[1], params[2])\n\t\t\t\tthis.rgbToHex()\n\t\t\t} else {\n\t\t\t\terror = \"Values of RGB exceed limits\"\n\t\t\t}\n\t\t}\n\n\t\tif (error !== null) {\n\t\t\tthrow \"Color type is incorrect. \" + error + \": \" + params.toString()\n\t\t}\n\t}\n\n\tpublic setRgb(r: number, g: number, b: number) {\n\t\tthis._colorRgb = {r: r, g: g, b: b} as RGB\n\t}\n\n\tpublic setHex(hexadecimal: string) {\n\t\tif (hexadecimal.length < 7) {\n\t\t\tlet hexVal1 = hexadecimal.charAt(1)\n\t\t\tlet hexVal2 = hexadecimal.charAt(2)\n\t\t\tlet hexVal3 = hexadecimal.charAt(3)\n\t\t\thexadecimal = \"#\" + hexVal1 + hexVal1 + hexVal2 + hexVal2 + hexVal3 + hexVal3\n\t\t}\n\t\tthis._colorHex = hexadecimal\n\t}\n\n\tpublic rgb(): RGB {\n\t\treturn this._colorRgb\n\t}\n\n\tpublic hex(): string {\n\t\treturn this._colorHex\n\t}\n\n\tvalidateRgb(rgb: number[]): boolean {\n\t\tif (rgb[0] > -1 && rgb[0] < 256 &&\n\t\t\trgb[1] > -1 && rgb[1] < 256 &&\n\t\t\trgb[2] > -1 && rgb[2] < 256) {\n\t\t\treturn true\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tvalidateHex(hex: string): boolean {\n\t\tlet regex = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/\n\t\tif (hex.match(regex)) {\n\t\t\treturn true\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n\n\thexToRgb() {\n\t\tlet hexValues: string[] = this._colorHex.substr(1).split('')\n\t\tlet hexPair1 = (this._hexNames.indexOf(hexValues[0]) * 16) + this._hexNames.indexOf(hexValues[1])\n\t\tlet hexPair2 = (this._hexNames.indexOf(hexValues[2]) * 16) + this._hexNames.indexOf(hexValues[3])\n\t\tlet hexPair3 = (this._hexNames.indexOf(hexValues[4]) * 16) + this._hexNames.indexOf(hexValues[5])\n\t\tthis.setRgb(hexPair1, hexPair2, hexPair3)\n\t\tthis.rgbToHex()\n\t}\n\n\trgbToHex() {\n\t\tif (typeof this._colorRgb === 'object') {\n\t\t\tlet r = this._colorRgb.r\n\t\t\tlet b = this._colorRgb.b\n\t\t\tlet g = this._colorRgb.g\n\t\t\tlet hexR = Number(r).toString(16)\n\t\t\tlet hexG = Number(g).toString(16)\n\t\t\tlet hexB = Number(b).toString(16)\n\t\t\tthis._colorHex = \"#\" + hexR + hexG + hexB\n\t\t}\n\t}\n}\n\nexport interface RGB {\n\tr: 0,\n\tg: 0,\n\tb: 0\n}\n","import { MapGenerationFunctions, BuildingHeightVariations } from './mapGenerationFunctions.component'\nimport { Tile, TileType } from './tile.component'\nimport { Config } from './config.component'\n\nexport default class Map {\n\n\tprivate _mapWidth: number\n\tprivate _mapLength: number\n\tprivate _mapMaxHeight: number\n\tprivate _averageBuildingSize: number\n\tprivate _blockHeight: number\n\tprivate _maximumBlockIterations: number\n\tprivate _additionalBlockIterations: number\n\tprivate _mapEdgeWidth: number\n\tprivate _highestPoint: number\n\tprivate _startBlockXfromCenterDeviation: number\n\tprivate _world: any[][]\n\tprivate _blockHeightsArray: number[]\n\tprivate _blockGroupCollection: any[]\n\tprivate _blockGroups: any[]\n\tprivate _startBlockEdges: number[]\n\tprivate _additionalBlockEdges: number[]\n\tprivate _mapGen: MapGenerationFunctions = new MapGenerationFunctions()\n\tprivate config: Config = new Config()\n\tprivate _blockHeightVariationLabels = [BuildingHeightVariations.TallCenter, BuildingHeightVariations.TallSurrounds, BuildingHeightVariations.Random]\n\tprivate _blockHeightVariation = this._blockHeightVariationLabels[Math.floor(Math.random() * 3)]\n\n\tconstructor(\t\n\t\t\tmapWidth: number, \n\t\t\tmapLength: number, \n\t\t\tmapMaxHeight: number, \n\t\t\tmapEdgeWidth: number,\n\t\t\taverageBuildingSize: number,\n\t\t\tblockHeight: number,\n\t\t\tmaximumBlockIterations: number)\n\t{\n\t\tthis._mapWidth = mapWidth\n\t\tthis._mapLength = mapLength\n\t\tthis._mapMaxHeight = mapMaxHeight\n\t\tthis._mapEdgeWidth = mapEdgeWidth\n\t\tthis._averageBuildingSize = averageBuildingSize\n\t\tthis._blockHeight = blockHeight\n\t\tthis._maximumBlockIterations = maximumBlockIterations\n\t\tthis._additionalBlockIterations = this._mapGen.calculateAdditionalBlockIterations(maximumBlockIterations)\n\t\tthis._blockGroups = []\n\n\t\tlet mapLengthHalf = Math.floor(mapLength / 2)\n\t\tlet mapWidthHalf = Math.floor(mapWidth / 2)\n\t\tlet startBlockXfromCenterDeviation = 6\n\t\tlet startblockLength = (this._averageBuildingSize + 1) + Math.floor(Math.random() * 6)\n\t\tlet startblockWidth = this._averageBuildingSize + Math.floor(Math.random() * 5)\n\t\tlet startblockXfromCenter = 6 + Math.floor(Math.random() * startBlockXfromCenterDeviation)\n\t\tlet startblockLengthHalf = Math.floor(startblockLength / 2)\n\t\tlet startblockWidthHalf = Math.floor(startblockWidth / 2)\n\t\tlet startingPositionX = Math.floor(this._mapWidth / 2) - Math.floor(startblockXfromCenter / 2)\n\n\t\tthis._world = []\n\t\tlet i = 0\n\t\tlet tileHeight = 0\n\t\tlet firstBlockHeight\n\n\t\tif (this._blockHeightVariation == BuildingHeightVariations.TallCenter) {\n\t\t\tfirstBlockHeight = blockHeight * 2\n\t\t} else if (this._blockHeightVariation == BuildingHeightVariations.TallSurrounds) {\n\t\t\tfirstBlockHeight = 1 + Math.round(Math.random())\n\t\t\tblockHeight = firstBlockHeight\n\t\t} else {\n\t\t\tfirstBlockHeight = blockHeight\n\t\t}\n\n\t\tconsole.log(\"Block height variation: \" + this._blockHeightVariation)\n\n\t\tfor (let y = 0; y < this.mapLength; y++) {\n\n\t\t\tthis._world[y] = []\n\n\t\t\tfor (let x = 0; x < this.mapWidth; x++) {\n\n\t\t\t\tlet thisBlockGroup = 0\n\n\t\t\t\tlet column = new Column(false, x, y, 0)\n\n\t\t\t\tif (y >= mapLengthHalf && y <= (mapLengthHalf + startblockLengthHalf) ) {\n\n\t\t\t\t\tif (x > startingPositionX && x <= (startingPositionX + startblockWidth) ) {\n\n\t\t\t\t\t\tthisBlockGroup = 1\n\t\t\t\t\t\tlet tileStack = []\n\n\t\t\t\t\t\tfor (let h = 0; h < firstBlockHeight; h++) {\n\n\t\t\t\t\t\t\tlet thisPillar = 0\n\t\t\t\t\t\t\tlet thisWindowed = 0\n\t\t\t\t\t\t\tlet isRoof = (h === firstBlockHeight-1) ? true : false\n\n\t\t\t\t\t\t\ttileStack.push(\n\t\t\t\t\t\t\t\tnew Tile(\n\t\t\t\t\t\t\t\t\ti, \n\t\t\t\t\t\t\t\t\tx, \n\t\t\t\t\t\t\t\t\ty, \n\t\t\t\t\t\t\t\t\th, \n\t\t\t\t\t\t\t\t\tTileType.Body,\n\t\t\t\t\t\t\t\t\tthis.config.buildingBaseColor,\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t'roof':\t\t\tisRoof,\n\t\t\t\t\t\t\t\t\t\t'pillar': \t\tthisPillar,\n\t\t\t\t\t\t\t\t\t\t'windowed': \tthisWindowed,\n\t\t\t\t\t\t\t\t\t\t'tower': \t\tfalse\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\tif (this._blockGroups.indexOf(thisBlockGroup) === -1) {\n\t\t\t\t\t\t\t\tthis._blockGroups[thisBlockGroup] = new Array( [y,x] )\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._blockGroups[thisBlockGroup].push([y,x])\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcolumn = new Column(true, x, y, firstBlockHeight)\n\n\t\t\t\t\t\tcolumn.blockGroup = thisBlockGroup\n\t\t\t\t\t\tcolumn.height = firstBlockHeight\n\t\t\t\t\t\tcolumn.corner = false\n\t\t\t\t\t\tcolumn.tileStack = tileStack\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._world[y][x] = column\n\t\t\t}\n\t\t}\n\n\t\tthis.setEdges()\n\t}\n\n\tget mapWidth(): number {\n\t\treturn this._mapWidth\n\t}\n\n\tget mapLength(): number {\n\t\treturn this._mapLength\n\t}\n\n\tget map(): any[] {\n\t\treturn this._world\n\t}\n\n\tpublic getColumn(x, y): Column {\n\t\treturn this._world[y][x]\n\t}\n\n\tpublic getTiles(x, y): Tile[] {\n\t\treturn this._world[y][x].tileStack\n\t}\n\n\tpublic getTile(x, y, h): Tile {\n\t\treturn this._world[y][x].getTile(h)\n\t}\n\n\tpublic getTopTile(x, y): Tile {\n\t\tlet height = this._world[y][x].height\n\t\treturn this._world[y][x].getTile(height-1)\n\t}\n\n\tsetEdges(): void {\n\n\t\tfor (let y = 0; y < this.mapLength; y++) {\n\t\t\tfor (let x = 0; x < this.mapWidth; x++) {\n\t\t\t\t\n\t\t\t\tif (y > 0 && x > 0 && y < this.mapLength-1 && x < this.mapWidth-1 && this._world[y][x].isDefined) {\n\n\t\t\t\t\tif (!this._world[y-1][x].isDefined) {\n\t\t\t\t\t\tthis._world[y][x].edge.top = true\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!this._world[y+1][x].isDefined) {\n\t\t\t\t\t\tthis._world[y][x].edge.bottom = true\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!this._world[y][x-1].isDefined) {\n\t\t\t\t\t\tthis._world[y][x].edge.left = true\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!this._world[y][x+1].isDefined) {\n\t\t\t\t\t\tthis._world[y][x].edge.right = true\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( (this._world[y][x].edge['top'] && this._world[y][x].edge['right']) ||\n\t\t\t\t\t\t (this._world[y][x].edge['top'] && this._world[y][x].edge['left']) ||\n\t\t\t\t\t\t (this._world[y][x].edge['bottom'] && this._world[y][x].edge['right']) ||\n\t\t\t\t\t\t (this._world[y][x].edge['bottom'] && this._world[y][x].edge['left']) ) {\n\t\t\t\t\t\tthis._world[y][x].corner = true\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nclass Column {\n\n\tprivate _defined: boolean\n\tprivate _x: number\n\tprivate _y: number\n\tprivate _height: number\n\tprivate _blockGroup: number\n\tprivate _corner: boolean\n\tprivate _edge: object = { 'top': false, 'right': false, 'bottom': false, 'left': false }\n\tprivate _tileStack: Tile[] = []\n\n\tconstructor(private defined: boolean, private colX: number, private colY: number, private colHeight: number) {\n\t\tthis._defined = defined\n\t\tthis._x = colX\n\t\tthis._y = colY\n\t\tthis._height = colHeight\n\t}\n\n\tset x(x: number) {\n\t\tthis._x = x\n\t}\n\n\tset y(y: number) {\n\t\tthis._y = y\n\t}\n\n\tset height(height: number) {\n\t\tthis._height = height\n\t}\n\n\tset blockGroup(groupNum: number) {\n\t\tthis._blockGroup = groupNum\n\t}\n\n\tset corner(corner: boolean) {\n\t\tthis._corner = corner\n\t}\n\n\tset edge(edge: object) {\n\t\tthis._edge = edge\n\t}\n\n\tset tileStack(tiles: Tile[]) {\n\t\tthis._tileStack = tiles\n\t}\n\n\tget isDefined(): boolean {\n\t\treturn this._defined\n\t}\n\n\tget x(): number {\n\t\treturn this._x\n\t}\n\n\tget y(): number {\n\t\treturn this._y\n\t}\n\n\tget height(): number {\n\t\treturn this._height\n\t}\n\n\tget blockGroup(): number {\n\t\treturn this._blockGroup\n\t}\n\n\tget corner(): boolean {\n\t\treturn this._corner\n\t}\n\n\tget edge(): object {\n\t\treturn this._edge\n\t}\n\n\tget tileStack(): Tile[] {\n\t\treturn this._tileStack\n\t}\n\n\tpublic getTile(height: number): Tile {\n\t\treturn this._tileStack[height]\n\t}\n}\n","import { Color } from './mapGenerationFunctions.component'\n\nexport class Tile {\n\t\n\t_id: number\n\t_x: number\n\t_y: number\n\t_h: number\n\t_tileType: TileType\n\t_tileColor: Color\n\t_options?: object = {}\n\n\tconstructor(\t\t\t\n\t\t\tid: number,\n\t\t\tx: number,\n\t\t\ty: number,\n\t\t\th: number,\n\t\t\ttileType: TileType,\n\t\t\ttileColor: Color,\n\t\t\toptions?: object)\n\t{\n\t\tthis._id = id\n\t\tthis._x = x\n\t\tthis._y = y\n\t\tthis._h = h\n\t\tthis._tileType = tileType\n\t\tthis._tileColor = tileColor\n\n\t\tif (options) {\n\t\t\tthis._options = options\n\t\t}\n\t}\n\n\tget id(): number {\n\t\treturn this._id\n\t}\n\n\tget x(): number {\n\t\treturn this._x\n\t}\n\n\tget y(): number {\n\t\treturn this._y\n\t}\t\n\n\tget type(): TileType {\n\t\treturn this._tileType\n\t}\n\n\tget options(): object {\n\t\tif (this._tileType != TileType.None) {\n\t\t\treturn this._options\n\t\t} else {\n\t\t\treturn { 'defined': false }\n\t\t}\n\t}\n\n\tpublic getColor(): Color {\n\t\treturn this._tileColor\n\t}\n\n}\n\nexport enum TileType {\n\tNone = 'none',\n\tBody = 'body',\n\tTower = 'tower',\n\tRoof = 'roof'\n}\n"]}